timestamp,repo_name,bug_commit_sha,file_path,commit_message,issue_title,issue_body,llm_model,complexity_before_cc,complexity_before_cognitive,complexity_before_avg_params,complexity_before_total_tokens,llm_patch_applied,llm_tests_passed,ai_lines_added,ai_lines_deleted,ai_total_diff,complexity_after_llm_cc,complexity_after_llm_cognitive,complexity_after_llm_avg_params,complexity_after_llm_total_tokens,human_tests_passed,human_lines_added,human_lines_deleted,human_total_diff,complexity_after_human_cc,complexity_after_human_cognitive,complexity_after_human_avg_params,complexity_after_human_total_tokens
2025-10-11T15:02:54.981034,mahmoud/boltons,4815fc8dd1768da5f2d903846d2ab994aa57b0cf,,Test and fix for #348 (#349),LRU .values() and dict return old entries,"Hi,

First of all thanks for the excellent library!

I'm seeing strange results when using `LRU`: after replacing an existing entry with a new value, seems like the `keys()` and `values()` methods return the old value, instead of the new one. Using `__getitem__` and `.get` we have the expected behavior.

Here is a test showing this behavior:

```python
def test_lru():
    from boltons.cacheutils import LRU

    cache = LRU()

    # Add an entry.
    cache['a'] = 1
    
    # Normal __getitem__ access. 
    assert cache['a'] == 1  # passes.
    # Convert to dict.
    assert dict(cache) == {'a': 1}  # passes.
    # Another way to access the only value.
    assert list(cache.values())[0] == 1  # passes.

    # Replace the existing 'a' entry with a new value.
    cache['a'] = 200

    # __getitem__ works as expected.
    assert cache['a'] == 200  # passes.

    # Both dict and accessing via values() return the old entry: 1.
    assert dict(cache) == {'a': 200}  # fails.
    assert list(dict(cache).values())[0] == 200  # fails.
```

This test fails in the last asserts (of course to see the 2nd failure one needs to comment the first):

```pytest
Î» pytest foo.py
======================== test session starts ========================
platform win32 -- Python 3.10.9, pytest-7.4.2, pluggy-1.3.0
rootdir: c:\Users\bruno\projects\boltons
configfile: pytest.ini
collected 1 item

foo.py F                                                       [100%]

============================= FAILURES ==============================
_____________________________ test_lru ______________________________

    def test_lru():
        from boltons.cacheutils import LRU

        cache = LRU()

        # Add an entry.
        cache['a'] = 1

        # Normal __getitem__ access.
        assert cache['a'] == 1  # passes.
        # Convert to dict.
        assert dict(cache) == {'a': 1}  # passes.
        # Another way to access the only value.
        assert list(cache.values())[0] == 1  # passes.

        # Replace the existing 'a' entry with a new value.
        cache['a'] = 200

        # __getitem__ works as expected.
        assert cache['a'] == 200  # passes.

        # Both dict and accessing via values() return the old entry: 1.
>       assert dict(cache) == {'a': 200}  # fails.
E       AssertionError: assert {'a': 1} == {'a': 200}
E         Differing items:
E         {'a': 1} != {'a': 200}
E         Use -v to get more diff

foo.py:23: AssertionError
====================== short test summary info ======================
FAILED foo.py::test_lru - AssertionError: assert {'a': 1} == {'a': 200}
========================= 1 failed in 0.04s =========================
```

At first it seems like a bug? Or perhaps this usage is not meant to be supported?",manual_llm,198,135,1.69,4927,SKIPPED,SKIPPED,SKIPPED,SKIPPED,SKIPPED,SKIPPED,SKIPPED,SKIPPED,SKIPPED,True,44,9,53,199,135,1.68,5014
